<script>
// ========================================================================
// YEAR IN REVIEW ANIMATION
// ========================================================================

/**
 * Start Year in Review playback mode
 */
function startYearInReview() {
  if (isYearInReview) return; // Already running
  if (!globe || !TRIPS.length) return;
  
  isYearInReview = true;
  
  // Disable trip selection during playback
  selectedTripId = null;
  renderTripList();
  
  // Stop any existing animations
  stopPulseAnimation();
  
  // Stop auto-rotation during animation (less jarring)
  const controls = globe.controls();
  if (controls) {
    controls.autoRotate = false;
    if (idleTimeout) clearTimeout(idleTimeout);
  }
  
  // Visual feedback
  $('sparkle-btn').classList.add('animate-pulse-glow', 'border-accent');
  $('details-title').textContent = '✨ Year in Review';
  $('details-subtitle').textContent = 'Relive your travels...';
  $('details-route').innerHTML = '';
  $('details-stats').innerHTML = '';
  
  // Reset camera
  globe.pointOfView({ lat: 20, lng: -40, altitude: 2.5 }, 800);
  
  // Start sequence after camera settles
  setTimeout(() => {
    if (isYearInReview) {
      playTripSequence();
    }
  }, 900);
}

/**
 * Stop Year in Review and restore normal state
 */
function stopYearInReview() {
  isYearInReview = false;
  yearInReviewArcs = [];
  
  // Remove visual feedback
  $('sparkle-btn').classList.remove('animate-pulse-glow', 'border-accent');
  
  // Hide map overlay if visible
  const overlay = $('map-overlay');
  if (overlay) {
    overlay.classList.remove('visible', 'zooming-out');
  }
  
  // Clear traveling indicator and restore globe state
  if (globe) {
    globe.pointsData([]);
    globe.htmlElementsData([]);
    
    // Restore all arcs
    globe
      .arcsData(buildArcData())
      .arcDashLength(1)
      .arcDashGap(0)
      .arcsTransitionDuration(300);
    
    // Resume auto-rotation
    const controls = globe.controls();
    if (controls) {
      controls.autoRotate = true;
    }
  }
  
  // Reset details panel
  renderDetails(null);
}

/**
 * Stop single trip animation
 */
function stopTripAnimation() {
  isTripAnimating = false;
  tripAnimationArcs = [];
  
  // Hide map overlay if visible
  const overlay = $('map-overlay');
  if (overlay) {
    overlay.classList.remove('visible', 'zooming-out');
  }
  
  // Clear traveling indicator and restore globe state
  if (globe) {
    globe.pointsData([]);
    globe.htmlElementsData([]);
    globe.arcsTransitionDuration(300);
    
    // Resume auto-rotation
    const controls = globe.controls();
    if (controls) controls.autoRotate = true;
  }
}

/**
 * Play animation for a single selected trip
 */
async function playSingleTripAnimation(trip) {
  if (!trip || !globe) return;
  
  isTripAnimating = true;
  tripAnimationArcs = [];
  
  // Stop auto-rotation during animation
  const controls = globe.controls();
  if (controls) controls.autoRotate = false;
  
  // Mute all other trips first - set them with muted color
  const allArcs = buildArcData();
  const otherArcs = allArcs
    .filter(a => a.tripId !== trip.id)
    .map(a => ({ ...a, color: 'rgba(74, 74, 90, 0.3)' })); // Muted color
  
  // Instant updates during animation
  globe.arcsTransitionDuration(0);
  globe.arcsData(otherArcs);
  globe.arcDashLength(1).arcDashGap(0);
  
  // Get arcs for this trip only
  const tripArcs = buildArcDataForTrip(trip);
  
  // Group consecutive legs by whether they use map overlay
  let i = 0;
  while (i < tripArcs.length) {
    if (!isTripAnimating) break;
    
    const arc = tripArcs[i];
    const leg = trip.legs[i];
    
    // Check if this leg should use 2D map overlay
    if (shouldUseMapOverlay(arc, leg)) {
      // Find all consecutive map-worthy legs starting from i
      const mapLegsGroup = [];
      let j = i;
      while (j < tripArcs.length && shouldUseMapOverlay(tripArcs[j], trip.legs[j])) {
        mapLegsGroup.push({ arc: tripArcs[j], leg: trip.legs[j], index: j });
        j++;
      }
      
      // Animate the entire group on the map
      await animateMapLegGroupForTrip(mapLegsGroup, trip, otherArcs);
      
      i = j;
    } else {
      // Use globe for flights and long legs
      await focusOnLeg(arc, leg);
      
      // Update route display to highlight current leg
      updateRouteHighlight(trip, i);
      
      // Add this arc to accumulated arcs (along with muted other arcs)
      tripAnimationArcs.push(arc);
      globe.arcsData([...otherArcs, ...tripAnimationArcs]);
      
      // Animation duration scales with distance
      const animDuration = Math.max(800, Math.min(2000, arc.distance * 0.5 + 600));
      
      // Animate traveling dot along the arc
      await animateTravelIndicator(arc, animDuration);
      
      await sleep(300);
      i++;
    }
  }
  
  // Animation complete - show final state
  if (isTripAnimating) {
    // Restore normal arc display with proper colors
    globe.arcsTransitionDuration(300);
    globe.arcsData(buildArcData()); // Rebuild with correct selection colors
    focusOnTrip(); // Zoom to show entire trip
    
    // Resume auto-rotation
    if (controls) controls.autoRotate = true;
  }
  
  isTripAnimating = false;
}

/**
 * Animate map leg group for single trip animation
 */
async function animateMapLegGroupForTrip(legsGroup, trip, otherArcs) {
  if (!legsGroup.length || !isTripAnimating) return;
  
  const firstLeg = legsGroup[0];
  
  // Zoom globe in toward the first leg's location
  const centerLat = (firstLeg.arc.startLat + firstLeg.arc.endLat) / 2;
  const centerLng = (firstLeg.arc.startLng + firstLeg.arc.endLng) / 2;
  globe.pointOfView({ lat: centerLat, lng: centerLng, altitude: 0.3 }, 600);
  await sleep(500);
  
  // Show map overlay once for the entire group
  await showMapOverlay(firstLeg.arc, firstLeg.leg);
  
  // Animate each leg in the group
  for (const { arc, leg, index } of legsGroup) {
    if (!isTripAnimating) break;
    
    // Update route highlight
    updateRouteHighlight(trip, index);
    
    // Add arc to accumulated arcs
    tripAnimationArcs.push(arc);
    globe.arcsData([...otherArcs, ...tripAnimationArcs]);
    
    // Pan map to this leg (if not the first)
    if (arc !== firstLeg.arc) {
      await panMapToLeg(arc, leg);
    }
    
    // Animate route on the 2D map
    const animDuration = Math.max(1000, Math.min(2500, arc.distance * 3 + 800));
    await animateRouteOnMap(arc, animDuration);
    
    await sleep(200);
  }
  
  // Transition back to globe after entire group is done
  await hideMapOverlay();
}

/**
 * Play through all trips sequentially in date order
 */
async function playTripSequence() {
  // Sort trips by start date
  const sortedTrips = [...TRIPS].sort((a, b) => 
    parseLocalDate(a.startDate) - parseLocalDate(b.startDate)
  );
  
  // Fade all arcs to invisible
  yearInReviewArcs = [];
  globe.arcsData([]);
  globe.arcDashLength(1).arcDashGap(0);
  await sleep(300);
  
  // Play each trip
  for (const trip of sortedTrips) {
    if (!isYearInReview) break; // Cancelled
    
    await playTripAnimation(trip);
    await sleep(600); // Pause between trips
  }
  
  // Finish: restore all arcs with draw-in
  if (isYearInReview) {
    // Show completion message
    $('details-subtitle').textContent = 'Journey complete!';
    await sleep(800);
    
    // Animate all arcs back in
    globe.arcsData(buildArcData());
    globe.arcDashLength(0).arcDashGap(2);
    
    await new Promise(resolve => {
      animateDrawIn(1500, resolve);
    });
    
    globe.arcDashLength(1).arcDashGap(0).arcsTransitionDuration(300);
    
    // End Year in Review mode
    isYearInReview = false;
    yearInReviewArcs = [];
    $('sparkle-btn').classList.remove('animate-pulse-glow', 'border-accent');
    renderDetails(null);
    
    // Resume auto-rotation
    const controls = globe.controls();
    if (controls) {
      controls.autoRotate = true;
    }
  }
}

/**
 * Animate a single trip during Year in Review
 */
async function playTripAnimation(trip) {
  if (!isYearInReview) return;
  
  // Update details panel with current trip
  $('details-title').textContent = trip.name;
  $('details-subtitle').textContent = formatDateRange(trip.startDate, trip.endDate);
  
  // Build route display using mode-aware display
  if (trip.legs && trip.legs.length > 0) {
    const route = [
      getLocationDisplay(trip.legs[0].origin, trip.legs[0].mode),
      ...trip.legs.map(l => getLocationDisplay(l.destination, l.mode))
    ];
    $('details-route').innerHTML = route.map((code, i) => 
      `<span class="text-accent font-medium">${code}</span>${i < route.length - 1 ? '<span class="text-route-active">→</span>' : ''}`
    ).join('');
  }
  
  // Get arcs for this trip only
  const tripArcs = buildArcDataForTrip(trip);
  
  // Group consecutive legs by whether they use map overlay
  let i = 0;
  while (i < tripArcs.length) {
    if (!isYearInReview) return;
    
    const arc = tripArcs[i];
    const leg = trip.legs[i];
    
    // Check if this leg should use 2D map overlay
    if (shouldUseMapOverlay(arc, leg)) {
      // Find all consecutive map-worthy legs starting from i
      const mapLegsGroup = [];
      let j = i;
      while (j < tripArcs.length && shouldUseMapOverlay(tripArcs[j], trip.legs[j])) {
        mapLegsGroup.push({ arc: tripArcs[j], leg: trip.legs[j], index: j });
        j++;
      }
      
      // Animate the entire group on the map without returning to globe
      await animateMapLegGroup(mapLegsGroup, trip);
      
      i = j; // Skip past all the legs we just animated
    } else {
      // Use globe for flights and long legs
      // Focus camera on this specific leg (zooms based on distance)
      await focusOnLeg(arc, leg);
      
      // Update route display to highlight current leg
      updateRouteHighlight(trip, i);
      
      // Add this arc to accumulated arcs
      yearInReviewArcs.push(arc);
      globe.arcsData([...yearInReviewArcs]);
      
      // Animation duration scales with distance (min 800ms, max 2000ms)
      const animDuration = Math.max(800, Math.min(2000, arc.distance * 0.5 + 600));
      
      // Animate traveling dot along the arc
      await animateTravelIndicator(arc, animDuration);
      
      // Brief pause after leg
      await sleep(300);
      
      i++;
    }
  }
  
  // Highlight trip in sidebar briefly
  highlightTripInList(trip.id);
}

/**
 * Animate a group of consecutive short/ground legs on the 2D map
 * Stays in map view for the entire group, only transitioning once
 */
async function animateMapLegGroup(legsGroup, trip) {
  if (!legsGroup.length || !isYearInReview) return;
  
  const firstLeg = legsGroup[0];
  
  // Zoom globe in toward the first leg's location
  const centerLat = (firstLeg.arc.startLat + firstLeg.arc.endLat) / 2;
  const centerLng = (firstLeg.arc.startLng + firstLeg.arc.endLng) / 2;
  globe.pointOfView({ lat: centerLat, lng: centerLng, altitude: 0.3 }, 600);
  await sleep(500);
  
  // Show map overlay once for the entire group
  await showMapOverlay(firstLeg.arc, firstLeg.leg);
  
  // Animate each leg in the group
  for (const { arc, leg, index } of legsGroup) {
    if (!isYearInReview) break;
    
    // Update route highlight
    updateRouteHighlight(trip, index);
    
    // Add arc to accumulated arcs
    yearInReviewArcs.push(arc);
    globe.arcsData([...yearInReviewArcs]);
    
    // Pan map to this leg (if not the first)
    if (arc !== firstLeg.arc) {
      await panMapToLeg(arc, leg);
    }
    
    // Animate route on the 2D map
    const animDuration = Math.max(1000, Math.min(2500, arc.distance * 3 + 800));
    await animateRouteOnMap(arc, animDuration);
    
    // Brief pause between legs in the group
    await sleep(200);
  }
  
  // Transition back to globe after entire group is done
  await hideMapOverlay();
}

/**
 * Pan the Leaflet map to show a new leg (used when staying in map view)
 */
async function panMapToLeg(arc, leg) {
  if (!leafletMap) return;
  
  // Clear previous route and markers (except tile layer)
  leafletMap.eachLayer(layer => {
    if (layer instanceof L.Marker || layer instanceof L.Polyline) {
      leafletMap.removeLayer(layer);
    }
  });
  
  // Calculate bounds for this leg
  const bounds = L.latLngBounds(
    [arc.startLat, arc.startLng],
    [arc.endLat, arc.endLng]
  );
  
  // Animate pan/zoom to new bounds
  leafletMap.flyToBounds(bounds, { 
    padding: [80, 80],
    maxZoom: 14,
    duration: 0.8
  });
  
  await sleep(850);
  
  // Add new route line
  const routeCoords = [[arc.startLat, arc.startLng], [arc.endLat, arc.endLng]];
  mapRouteLayer = L.polyline(routeCoords, {
    color: '#f4a261',
    weight: 4,
    opacity: 0.9,
    dashArray: '0, 1000'
  }).addTo(leafletMap);
  
  // Add origin label
  const originName = getLocationDisplay(leg?.origin, leg?.mode) || 'Origin';
  L.marker([arc.startLat, arc.startLng], {
    icon: L.divIcon({
      className: 'map-label origin',
      html: originName,
      iconSize: null
    })
  }).addTo(leafletMap);
  
  // Add destination label
  const destName = getLocationDisplay(leg?.destination, leg?.mode) || 'Destination';
  L.marker([arc.endLat, arc.endLng], {
    icon: L.divIcon({
      className: 'map-label destination',
      html: destName,
      iconSize: null
    })
  }).addTo(leafletMap);
}

/**
 * Update route display to highlight current leg
 */
function updateRouteHighlight(trip, currentLegIndex) {
  if (!trip.legs || trip.legs.length === 0) return;
  
  const route = [
    getLocationDisplay(trip.legs[0].origin, trip.legs[0].mode),
    ...trip.legs.map(l => getLocationDisplay(l.destination, l.mode))
  ];
  
  $('details-route').innerHTML = route.map((code, i) => {
    // Highlight origin and destination of current leg
    const isCurrentOrigin = i === currentLegIndex;
    const isCurrentDest = i === currentLegIndex + 1;
    const isCurrent = isCurrentOrigin || isCurrentDest;
    
    const colorClass = isCurrent ? 'text-route-active font-semibold' : 'text-accent/60 font-medium';
    const arrow = i < route.length - 1 
      ? `<span class="${i === currentLegIndex ? 'text-route-active' : 'text-slate-500'}">→</span>` 
      : '';
    
    return `<span class="${colorClass}">${code}</span>${arrow}`;
  }).join('');
}

/**
 * Focus camera on a single leg with distance-appropriate zoom
 */
async function focusOnLeg(arc, leg) {
  // Calculate center point of the leg
  const centerLat = (arc.startLat + arc.endLat) / 2;
  const centerLng = (arc.startLng + arc.endLng) / 2;
  
  // Calculate altitude based on distance - closer for short legs
  const altitude = calculateLegAltitude(arc.distance, leg?.mode);
  
  // Camera transition time scales with distance
  const transitionTime = Math.max(500, Math.min(1000, arc.distance * 0.1 + 400));
  
  globe.pointOfView({ lat: centerLat, lng: centerLng, altitude }, transitionTime);
  
  // Wait for camera to settle
  await sleep(transitionTime + 200);
}

/**
 * Calculate camera altitude for focusing on a leg based on distance
 * Returns much closer zoom for short distances
 */
function calculateLegAltitude(distanceKm, mode) {
  // Surface travel (car/train/ferry) - zoom in extra close
  if (mode === 'train' || mode === 'car' || mode === 'ferry') {
    if (distanceKm < 30) return 0.15;      // Very short: extremely close
    if (distanceKm < 50) return 0.2;       // Short city-to-city
    if (distanceKm < 100) return 0.3;      // Regional
    if (distanceKm < 200) return 0.5;      // Longer regional
    if (distanceKm < 500) return 0.8;      // Cross-region
    return 1.0;                             // Very long surface travel
  }
  
  // Flights - more traditional zoom levels
  if (distanceKm < 300) return 0.6;        // Very short flight
  if (distanceKm < 800) return 0.9;        // Short regional
  if (distanceKm < 1500) return 1.2;       // Regional
  if (distanceKm < 3000) return 1.6;       // Medium distance
  if (distanceKm < 6000) return 2.0;       // Long haul
  return 2.5;                               // Ultra long haul
}

/**
 * Interpolate along a great circle path between two points.
 * Uses spherical linear interpolation (slerp) to match Globe.gl's arc rendering.
 * @param {number} lat1 - Start latitude in degrees
 * @param {number} lng1 - Start longitude in degrees
 * @param {number} lat2 - End latitude in degrees
 * @param {number} lng2 - End longitude in degrees
 * @param {number} t - Interpolation factor (0 to 1)
 * @returns {{lat: number, lng: number}} Interpolated position
 */
function interpolateGreatCircle(lat1, lng1, lat2, lng2, t) {
  // Convert to radians
  const toRad = deg => deg * Math.PI / 180;
  const toDeg = rad => rad * 180 / Math.PI;
  
  const φ1 = toRad(lat1);
  const λ1 = toRad(lng1);
  const φ2 = toRad(lat2);
  const λ2 = toRad(lng2);
  
  // Calculate angular distance between points
  const Δλ = λ2 - λ1;
  const cosφ1 = Math.cos(φ1);
  const cosφ2 = Math.cos(φ2);
  const sinφ1 = Math.sin(φ1);
  const sinφ2 = Math.sin(φ2);
  
  const d = Math.acos(
    sinφ1 * sinφ2 + cosφ1 * cosφ2 * Math.cos(Δλ)
  );
  
  // Handle very short distances (avoid division by zero)
  if (d < 0.0001) {
    return {
      lat: lat1 + (lat2 - lat1) * t,
      lng: lng1 + (lng2 - lng1) * t
    };
  }
  
  // Spherical linear interpolation
  const sinD = Math.sin(d);
  const a = Math.sin((1 - t) * d) / sinD;
  const b = Math.sin(t * d) / sinD;
  
  // Calculate 3D Cartesian coordinates
  const x = a * cosφ1 * Math.cos(λ1) + b * cosφ2 * Math.cos(λ2);
  const y = a * cosφ1 * Math.sin(λ1) + b * cosφ2 * Math.sin(λ2);
  const z = a * sinφ1 + b * sinφ2;
  
  // Convert back to lat/lng
  const φ = Math.atan2(z, Math.sqrt(x * x + y * y));
  const λ = Math.atan2(y, x);
  
  return {
    lat: toDeg(φ),
    lng: toDeg(λ)
  };
}

/**
 * Calculate the bearing (direction) between two points in degrees
 */
function calculateBearing(lat1, lng1, lat2, lng2) {
  const toRad = deg => deg * Math.PI / 180;
  const toDeg = rad => rad * 180 / Math.PI;
  
  const φ1 = toRad(lat1);
  const φ2 = toRad(lat2);
  const Δλ = toRad(lng2 - lng1);
  
  const y = Math.sin(Δλ) * Math.cos(φ2);
  const x = Math.cos(φ1) * Math.sin(φ2) - Math.sin(φ1) * Math.cos(φ2) * Math.cos(Δλ);
  
  return (toDeg(Math.atan2(y, x)) + 360) % 360;
}

// Persistent inner icon element - we rotate this directly
let innerIconElement = null;
let currentIconMode = null;

/**
 * Get or create the inner icon SVG element.
 * This is reused and rotated directly each frame.
 */
function getInnerIcon(mode) {
  if (innerIconElement && currentIconMode === mode) {
    return innerIconElement;
  }
  
  currentIconMode = mode;
  innerIconElement = document.createElement('div');
  innerIconElement.style.cssText = `
    display: flex; 
    align-items: center; 
    justify-content: center;
  `;
  
  // Icon color - white for visibility against the orange arc
  const color = '#ffffff';
  const shadow = 'filter: drop-shadow(0 0 6px rgba(255,255,255,0.8)) drop-shadow(0 2px 4px rgba(0,0,0,0.6));';
  
  // Material Symbols icons (Apache 2.0) - all point North/Up by default
  const icons = {
    // Material Symbol: flight (natively points North/Up)
    flight: `
      <svg viewBox="0 0 24 24" width="28" height="28" style="${shadow}">
        <path d="M21 16v-2l-8-5V3.5c0-.83-.67-1.5-1.5-1.5S10 2.67 10 3.5V9l-8 5v2l8-2.5V19l-2 1.5V22l3.5-1 3.5 1v-1.5L13 19v-5.5l8 2.5z" fill="${color}"/>
      </svg>`,
    // Material Symbol: train (Front view = North)
    train: `
      <svg viewBox="0 0 24 24" width="24" height="24" style="${shadow}">
        <path d="M12 2c-4 0-8 .5-8 4v9.5C4 17.43 5.57 19 7.5 19L6 20.5v.5h12v-.5L16.5 19c1.93 0 3.5-1.57 3.5-3.5V6c0-3.5-3.96-4-8-4zm0 2c3.5 0 6 .5 6 2v2H6V6c0-1.5 2.5-2 6-2zm6 11.5c0 .83-.67 1.5-1.5 1.5h-9c-.83 0-1.5-.67-1.5-1.5V12h12v3.5zm-6-2.5c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2z" fill="${color}"/>
      </svg>`,
    // Material Symbol: directions_car (Front view = North)
    car: `
      <svg viewBox="0 0 24 24" width="24" height="24" style="${shadow}">
        <path d="M18.92 6.01C18.72 5.42 18.16 5 17.5 5h-11c-.66 0-1.21.42-1.42 1.01L3 12v8c0 .55.45 1 1 1h1c.55 0 1-.45 1-1v-1h12v1c0 .55.45 1 1 1h1c.55 0 1-.45 1-1v-8l-2.08-5.99zM6.5 16c-.83 0-1.5-.67-1.5-1.5S5.67 13 6.5 13s1.5.67 1.5 1.5S7.33 16 6.5 16zm11 0c-.83 0-1.5-.67-1.5-1.5s.67-1.5 1.5-1.5 1.5.67 1.5 1.5-.67 1.5-1.5 1.5zM5 11l1.5-4.5h11L19 11H5z" fill="${color}"/>
      </svg>`,
    // Custom top-down ferry (Material's boat is side-view)
    ferry: `
      <svg viewBox="0 0 24 24" width="24" height="24" style="${shadow}">
        <path d="M12 2C9 2 7 4 7 7v10c0 3 2 5 5 5s5-2 5-5V7c0-3-2-5-5-5zm0 2c1.5 0 3 1.5 3 3v9c0 1.5-1.5 3-3 3s-3-1.5-3-3V7c0-1.5 1.5-3 3-3z" fill="${color}"/>
        <rect x="9" y="8" width="6" height="8" rx="1" fill="#0a0a1a" opacity="0.3"/>
      </svg>`
  };
  
  innerIconElement.innerHTML = icons[mode] || icons.flight;
  return innerIconElement;
}

/**
 * Create a wrapper containing a rotated clone of the icon.
 * - New wrapper each frame → Globe.gl repositions it
 * - Cloned icon with rotation applied → consistent appearance
 */
function createIconWrapper(mode, bearing) {
  const iconTemplate = getInnerIcon(mode);
  const iconClone = iconTemplate.cloneNode(true);
  iconClone.style.transform = `rotate(${bearing}deg)`;
  
  const wrapper = document.createElement('div');
  wrapper.appendChild(iconClone);
  return wrapper;
}

/**
 * Animate a traveling indicator along an arc
 */
function animateTravelIndicator(arc, duration) {
  return new Promise(resolve => {
    const startTime = performance.now();
    
    // Check if animation should run (Year in Review OR single trip animation)
    const isAnimating = () => isYearInReview || isTripAnimating;
    
    // Altitude offset to position icon above the arc
    const altitudeOffset = 0.015;
    
    function tick(now) {
      if (!isAnimating()) {
        globe.htmlElementsData([]);
        innerIconElement = null;
        currentIconMode = null;
        resolve();
        return;
      }
      
      const t = Math.min((now - startTime) / duration, 1);
      
      // Ease-in-out for smoother travel feel
      const eased = t < 0.5 
        ? 2 * t * t 
        : 1 - Math.pow(-2 * t + 2, 2) / 2;
      
      // Interpolate position along great circle (matches Globe.gl arc rendering)
      const pos = interpolateGreatCircle(
        arc.startLat, arc.startLng,
        arc.endLat, arc.endLng,
        eased
      );
      
      // Calculate altitude to match the arc's visual height (parabolic curve)
      // arc.altitude is already the peak height as a proportion of globe radius
      const arcAltitude = arc.altitude * 4 * eased * (1 - eased);
      // Position icon slightly above the arc
      const altitude = arcAltitude + altitudeOffset;
      
      // Calculate bearing for icon rotation
      const lookAhead = Math.min(eased + 0.01, 1);
      const nextPos = interpolateGreatCircle(
        arc.startLat, arc.startLng,
        arc.endLat, arc.endLng,
        lookAhead
      );
      const bearing = calculateBearing(pos.lat, pos.lng, nextPos.lat, nextPos.lng);
      
      // Create wrapper with rotated icon inside
      // - New wrapper each frame → Globe.gl repositions correctly
      // - Same inner icon → rotation updates work
      const wrapper = createIconWrapper(arc.mode, bearing);
      
      globe
        .htmlElementsData([{ lat: pos.lat, lng: pos.lng, altitude }])
        .htmlElement(() => wrapper)
        .htmlAltitude(d => d.altitude);
      
      if (t < 1 && isAnimating()) {
        requestAnimationFrame(tick);
      } else {
        globe.htmlElementsData([]); // Remove indicator
        innerIconElement = null;
        currentIconMode = null;
        resolve();
      }
    }
    
    requestAnimationFrame(tick);
  });
}

/**
 * Briefly highlight a trip in the sidebar list
 */
function highlightTripInList(tripId) {
  const tripItem = document.querySelector(`[data-trip-id="${tripId}"]`);
  if (tripItem) {
    tripItem.classList.add('border-accent', 'bg-accent/20');
    setTimeout(() => {
      tripItem.classList.remove('border-accent', 'bg-accent/20');
    }, 600);
  }
}

// ========================================================================
// 2D MAP OVERLAY FOR SHORT LEGS
// ========================================================================

/**
 * Initialize the Leaflet map (lazy - only when first needed)
 */
function initLeafletMap() {
  if (leafletMap) return; // Already initialized
  
  // Check if Leaflet is loaded
  if (typeof L === 'undefined') return;
  
  const mapContainer = $('leaflet-map');
  if (!mapContainer) return;
  
  // Create map with dark theme
  leafletMap = L.map(mapContainer, {
    zoomControl: false,
    attributionControl: false,
    dragging: false,
    scrollWheelZoom: false,
    doubleClickZoom: false,
    touchZoom: false
  });
  
  // Build tile URL dynamically to avoid Apps Script stripping curly braces
  // CartoDB Dark Matter tiles for dark theme
  var LB = String.fromCharCode(123); // {
  var RB = String.fromCharCode(125); // }
  var tileUrl = 'https:/' + '/' + LB + 's' + RB + '.basemaps.cartocdn.com/dark_all/' +
                LB + 'z' + RB + '/' + LB + 'x' + RB + '/' + LB + 'y' + RB + LB + 'r' + RB + '.png';
  
  L.tileLayer(tileUrl, {
    maxZoom: 19
  }).addTo(leafletMap);
}

/**
 * Check if a leg should use the 2D map overlay
 */
function shouldUseMapOverlay(arc, leg) {
  // Use map for short legs or ground transportation
  const isShort = arc.distance < SHORT_LEG_THRESHOLD;
  const isGround = leg?.mode === 'car' || leg?.mode === 'train' || leg?.mode === 'ferry';
  return isShort || isGround;
}

/**
 * Show the 2D map overlay with zoom-in transition
 * @param {Object} arc - Arc data with start/end coordinates
 * @param {Object} leg - Leg data with origin/destination info
 * @returns {Promise} Resolves when transition is complete
 */
async function showMapOverlay(arc, leg) {
  // Initialize map if needed
  initLeafletMap();
  if (!leafletMap) return;
  
  const overlay = $('map-overlay');
  if (!overlay) return;
  
  // Calculate bounds with padding
  const bounds = L.latLngBounds(
    [arc.startLat, arc.startLng],
    [arc.endLat, arc.endLng]
  );
  
  // Fit map to bounds
  leafletMap.fitBounds(bounds, { 
    padding: [80, 80],
    maxZoom: 14,
    animate: false
  });
  
  // Clear previous layers
  if (mapRouteLayer) {
    leafletMap.removeLayer(mapRouteLayer);
    mapRouteLayer = null;
  }
  if (mapMarkerLayer) {
    leafletMap.removeLayer(mapMarkerLayer);
    mapMarkerLayer = null;
  }
  
  // Add route line (initially hidden, will be drawn)
  const routeCoords = [[arc.startLat, arc.startLng], [arc.endLat, arc.endLng]];
  mapRouteLayer = L.polyline(routeCoords, {
    color: '#f4a261',
    weight: 4,
    opacity: 0.9,
    dashArray: '0, 1000' // Start hidden
  }).addTo(leafletMap);
  
  // Add origin label
  const originName = getLocationDisplay(leg?.origin, leg?.mode) || 'Origin';
  L.marker([arc.startLat, arc.startLng], {
    icon: L.divIcon({
      className: 'map-label origin',
      html: originName,
      iconSize: null
    })
  }).addTo(leafletMap);
  
  // Add destination label
  const destName = getLocationDisplay(leg?.destination, leg?.mode) || 'Destination';
  L.marker([arc.endLat, arc.endLng], {
    icon: L.divIcon({
      className: 'map-label destination',
      html: destName,
      iconSize: null
    })
  }).addTo(leafletMap);
  
  // Show overlay with zoom-in transition
  overlay.classList.remove('zooming-out');
  overlay.classList.add('visible');
  
  // Force Leaflet to recalculate size now that container is visible
  setTimeout(() => {
    if (leafletMap) leafletMap.invalidateSize();
  }, 50);
  
  // Wait for CSS transition
  await sleep(450);
}

/**
 * Animate the route on the 2D map with traveling marker
 * @param {Object} arc - Arc data
 * @param {number} duration - Animation duration in ms
 * @returns {Promise} Resolves when animation is complete
 */
function animateRouteOnMap(arc, duration) {
  return new Promise(resolve => {
    if (!leafletMap || !mapRouteLayer) {
      resolve();
      return;
    }
    
    // Check if animation should run (Year in Review OR single trip animation)
    const isAnimating = () => isYearInReview || isTripAnimating;
    
    if (!isAnimating()) {
      resolve();
      return;
    }
    
    const startTime = performance.now();
    const totalLength = arc.distance * 30; // Approximate dash length
    
    // Create traveling marker
    const markerIcon = L.divIcon({
      className: 'traveling-marker',
      html: `<div style="width: 12px; height: 12px; background: #f4a261; border-radius: 50%; box-shadow: 0 0 12px #f4a261, 0 0 24px #e76f51;"></div>`,
      iconSize: [12, 12],
      iconAnchor: [6, 6]
    });
    
    mapMarkerLayer = L.marker([arc.startLat, arc.startLng], { icon: markerIcon }).addTo(leafletMap);
    
    function tick(now) {
      if (!isAnimating()) {
        resolve();
        return;
      }
      
      const t = Math.min((now - startTime) / duration, 1);
      
      // Ease-in-out
      const eased = t < 0.5 
        ? 2 * t * t 
        : 1 - Math.pow(-2 * t + 2, 2) / 2;
      
      // Update route dash to "draw" the line
      mapRouteLayer.setStyle({
        dashArray: `${eased * totalLength}, ${totalLength}`
      });
      
      // Update marker position
      const lat = arc.startLat + (arc.endLat - arc.startLat) * eased;
      const lng = arc.startLng + (arc.endLng - arc.startLng) * eased;
      mapMarkerLayer.setLatLng([lat, lng]);
      
      if (t < 1 && isAnimating()) {
        requestAnimationFrame(tick);
      } else {
        // Brief pause at destination
        setTimeout(resolve, 200);
      }
    }
    
    requestAnimationFrame(tick);
  });
}

/**
 * Hide the 2D map overlay with zoom-out transition
 * @returns {Promise} Resolves when transition is complete
 */
async function hideMapOverlay() {
  const overlay = $('map-overlay');
  if (!overlay) return;
  
  // Trigger zoom-out transition
  overlay.classList.add('zooming-out');
  overlay.classList.remove('visible');
  
  // Wait for CSS transition
  await sleep(450);
  
  // Clean up map layers
  if (leafletMap) {
    leafletMap.eachLayer(layer => {
      if (layer instanceof L.Marker || layer instanceof L.Polyline) {
        leafletMap.removeLayer(layer);
      }
    });
    mapRouteLayer = null;
    mapMarkerLayer = null;
  }
  
  overlay.classList.remove('zooming-out');
}
</script>

